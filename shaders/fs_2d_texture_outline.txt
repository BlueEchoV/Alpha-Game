#version 330 core
in vec4 f_color;
in vec2 f_texture_coordinates;

out vec4 f_final_color;

uniform sampler2D texture_sampler;
uniform vec3 outline_color;         // RGB outline color (passed as uniform)
uniform float outline_thickness;    // Normalized thickness (e.g., 0.005 for thin outline)
uniform vec2 tex_size;              // Texture dimensions (for offset calculation)

void main() {
    vec4 tex_color = texture(texture_sampler, f_texture_coordinates) * f_color;  // Apply texture and modulation

    if (tex_color.a > 0.01) {  // Threshold to avoid faint artifacts
        f_final_color = tex_color;  // Interior pixel
    } else {
        // Sample neighbors to detect edge
        float max_alpha = 0.0;
        // The offset needed to sample one pixel away
        vec2 offset = vec2(outline_thickness / tex_size.x, outline_thickness / tex_size.y);
        // Loops through a 3x3 grid around the current pixel and checks if any of the pixels are not transparent.
        // If they aren't (alpha >= 0.01), than it must be a edge pixel. Therefore, output it as a solid outline color.
        for (float x = -1.0; x <= 1.0; x += 1.0) {
            for (float y = -1.0; y <= 1.0; y += 1.0) {
                if (x == 0.0 && y == 0.0) {
                    // Skip center
                    continue;
                }
                vec2 sample_coord = f_texture_coordinates + vec2(x * offset.x, y * offset.y);
                float sample_alpha = texture(texture_sampler, sample_coord).a;
                max_alpha = max(max_alpha, sample_alpha);
            }
        }
        if (max_alpha > 0.01) {
            f_final_color = vec4(outline_color, 1.0);  // Outline pixel
        } else {
            discard;  // Fully transparent
        }
    }
}
